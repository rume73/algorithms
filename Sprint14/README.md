# **Яндекс.Практикум. Спринт 14**

# Рекурсия и сортировки
https://contest.yandex.ru/contest/24734/problems/

## A. Генератор скобок
В Удотинске объявлен конкурс. Нужно написать самую быструю реализацию функции, 
которая генерирует все правильные скобочные последовательности длины n.
Вид скобок только один: ( )

На вход функция принимает n - целое число от 0 до 10.

Функция должна напечатать все возможные скобочные последовательности заданной 
длины в лексикографическом порядке.

## B. Комбинации
На клавиатуре старых мобильных телефонов каждой цифре соответствовало несколько букв. Примерно так:

2:'abc',
3:'def',
4:'ghi',
5:'jkl',
6:'mno',
7:'pqrs',
8:'tuv',
9:'wxyz'

Вам известно в каком порядке были нажаты кнопки телефона, без учета повторов. Напечатайте все комбинации букв, которые можно набрать такой последовательностью нажатий.

На вход подается строка, состоящая из цифр 2-9 включительно. Длина строки не превосходит 10 символов.

**Выведите все возможные комбинации букв через пробел.**

## C. Подпоследовательность
Вася любит играть в игру Подпоследовательность. 
Даны 2 строки, и нужно понять, является ли первая из них 
подпоследовательностью второй. Когда строки достаточно длинные, 
иногда очень трудно получить ответ на этот вопрос, просто посмотрев на них. 
Помогите Васе, напишите функцию, которая решает эту задачу.

В первой строке записана строка s.

Во второй — строка t.

Обе строки состоят из маленьких латинских букв, длины строк не превосходят 1000.

**Выведите True, если s является подпоследовательностью t, иначе — False.**

## G. Гардероб
Евлампия решила оставить у себя в гардеробе вещи только трех цветов: 
розового, желтого, и малинового. Она захотела отсортировать одежду по цветам. 
Сначала должны идти вещи розового цвета, далее - желтого, 
и в конце - малинового. Помогите Евлампии навести порядок в гардеробе.

В первой строке задано количество предметов в гардеробе: 
n - оно не превосходит 10000. Далее задан массив, в котором указан цвет 
для каждого предмета. Розовый цвет обозначен 0, желтый - 1, малиновый - 2. 
**Помогите Евлампии расположить предметы в гардеробе так в соответствии 
с её задумкой.**

## H. Большое число
Вечером ребята решили поиграть в игру "Большое число".
Даны числа. Нужно определить, какое самое большое число можно из них составить.

В первой строке записано n - количество чисел. Оно не превосходит 100.
Во второй строке через пробел записаны n неотрицательных чисел, каждое 
из которых не превосходит 1000.

**Нужно вывести самое большое число, которое можно из них составить.**

## J. Пузырек
Чтобы выбрать самый лучший алгоритм для решения задачи, 
Гоша взялся изучать разные сортировки. На очереди - сортировка пузырьком.

Алгоритм следующий (сортируем по возрастанию):
На каждом шаге проходим по массиву поочередно сравниваем пары соседних 
элементов. Если элемент на позиции i больше элемента на позиции i+1, 
меняем их местами. После первой итерации самый большой элемент окажется 
в конце массива.

Проходим по массиву, выполняя указанные действия n - 1 раз, или до тех пор, 
пока на очередной итерации не окажется, что обмены больше не нужны, 
то есть массив уже отсортирован.
Помогите Гоше написать код алгоритма.

В первой строке на вход подается число n - длина массива. 
n не превосходит 1000. Во второй строке через пробел записаны n чисел. 
Каждое из чисел по модулю не превосходит 1000.

**Нужно вывести через пробел числа в отсортированном порядке.**

## J. Пузырек
Гоше дали задание написать красивую сортировку слиянием. Поэтому Гоше обязательно надо реализовать отдельно функцию merge и функцию merge_sort.

Функция merge принимает два отсортированных массива, сливает их в один отсортированный массив и возвращает его. Если требуемая сигнатура имеет вид merge(array, left, mid, right), то первый массив задаётся полуинтервалом [left,mid) массива array, а второй – полуинтервалом [mid,right) массива array.
Функция merge_sort принимает некоторый подмассив, который нужно отсортировать. Подмассив задаётся полуинтервалом — его началом и концом. Функция должна отсортировать передаваемый в неё подмассив, она ничего не возвращает.
Функция merge_sort разбивает полуинтервал на две половинки и рекурсивно вызывает сортировку отдельно для каждой. Затем два отсортированных массива сливаются в один с помощью merge.

Заметьте, что в функции передаются именно полуинтервалы [begin,end), то есть правый конец не включается. Например, если вызвать merge_sort(arr, 0, 4), где arr=[4,5,3,0,1,2], то будут отсортированы только первые четыре элемента, изменённый массив будет выглядеть как arr=[0,3,4,5,1,2].

Передаваемый в функции массив состоит из целых чисел, не превосходящих по модулю 109. Длина сортируемого диапазона не превосходит 10^5. 

## L. Два велосипеда
Вася решил накопить денег на два одинаковых велосипеда — себе и сестре. У Васи есть копилка, в которую каждый день он может добавлять деньги (если, конечно, у него есть такая финансовая возможность). В процессе накопления Вася не вынимает деньги из копилки.

У вас есть информация о росте Васиных накоплений — сколько у Васи в копилке было денег в каждый из дней.

Ваша задача — по заданной стоимости велосипеда определить

- первый день, в которой Вася смог бы купить один велосипед,
- и первый день, в который Вася смог бы купить два велосипеда.



В первой строке дано число дней n, по которым велись наблюдения за Васиными накоплениями. 1 ≤ n ≤ 10^6.
В следующей строке записаны n целых неотрицательных чисел. Числа идут в порядке неубывания. Каждое из чисел не превосходит 10^6.
В третьей строке записано целое положительное число s — стоимость велосипеда. Это число не превосходит 10^6.


**Нужно вывести два числа — номера дней по условию задачи. Если необходимой суммы в копилке не нашлось, нужно вернуть -1 вместо номера дня.**

## N. Клумбы
Евлампия захотела, чтобы у нее под окном были клумбы с одуванчиками. 
Для работ по подготовке земельного участка под клумбы было нанято n садовников.
Каждый из садовников обрабатывал какой-то участок земли. 
Процесс был организован не очень хорошо, иногда один и тот же участок, 
или часть участка мог быть обработан сразу несколькими садовниками. 
Обработанный участок любого размера становился клумбой. 
В клумбе не могло быть необработанных промежутков.
Нужно определить границы получившихся клумб.

В первой строке задано количество садовников - n. 
Число садовников не превосходит 1000 В следующих n строках через пробел 
записаны координаты участков в формате:
start end Оба числа целые, неотрицательные, и не превосходят 1000. 
start не может быть больше, чем end

**Нужно вывести в отдельной строке координаты каждой из получившихся клумб.
Данные должны выводится в отсортированном порядке.**

# Финальные задачи
https://contest.yandex.ru/contest/24735/problems/

## A. Поиск в сломанном массиве
Алла ошиблась со структурой данных. Она решила хранить массив в кольцевом 
буфере.
Проблема в том, что массив был отсортирован. И в нем можно было искать 
элемент за логарифмическое время. Алла скопировала данные из кольцевого 
буфера а обычный массив. Но он больше не является отсортированным. 
Тем не менее нужно обеспечить возможность находить в нем элемент за O(logn).

В первой строке записано число n - длина массива.
Во второй строке записано положительное число k - искомый элемент.
n и k не превосходят 1000.
Далее в строку через пробел записаны n положительных чисел, 
каждое из которых не превосходит 1000.

**Выведите индекс искомого элемента в массиве, если он найден. Иначе выведите -1.**

## B. Эффективная быстрая сортировка
Тимофей решил организовать соревнование по спортивному программированию, чтобы найти талантливых стажёров. Задачи подобраны, участники зарегистрированы, тесты написаны. Осталось придумать, как в конце соревнования будет определяться победитель.
Каждый участник имеет уникальный логин. Когда соревнование закончится, к нему будут привязаны два показателя: количество решённых задач Pi и размер штрафа Fi. Штраф начисляется за неудачные попытки и время, затраченное на задачу.

Тимофей решил сортировать таблицу результатов следующим образом: при сравнении двух участников выше будет идти тот, у которого решено больше задач. При равенстве числа решённых задач первым идёт участник с меньшим штрафом. Если же и штрафы совпадают, то первым будет тот, у которого логин идёт раньше в алфавитном (лексикографическом) порядке.

Тимофей заказал толстовки для победителей и накануне поехал за ними в магазин. В своё отсутствие он поручил вам реализовать алгоритм быстрой сортировки (англ. quick sort) для таблицы результатов. Так как Тимофей любит спортивное программирование и не любит зря расходовать оперативную память, то ваша реализация сортировки не может потреблять O(n) дополнительной памяти для промежуточных данных (такая модификация быстрой сортировки называется "in-place").

В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
В каждой из следующих n строк задана информация про одного из участников.
i-й участник описывается тремя параметрами:
уникальным логином (строкой из маленьких латинских букв длиной не более 20)
числом решённых задач Pi
штрафом Fi
Fi и Pi — целые числа, лежащие в диапазоне от 0 до 10^9

**Для отсортированного списка участников выведите по порядку их логины по одному в строке.**
