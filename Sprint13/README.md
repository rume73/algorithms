# **Яндекс.Практикум. Спринт 13**

# Основные структуры данных
https://contest.yandex.ru/contest/23389/problems/

## A. Мониторинг:
Есть матрица размера m × n. Нужно написать функцию, которая её транспонирует.

В первой строке задано число n — количество строк матрицы.
Во второй строке задано m — число столбцов, m и n не превосходят 1000. В следующих n строках задана матрица. Числа в ней не превосходят по модулю 1000.

**Напечатайте транспонированную матрицу в том же формате, который задан во входных данных. Каждая строка матрицы выводится на отдельной строке, элементы разделяются пробелами.**

## B. Список дел
Васе нужно распечатать свой список дел на сегодня. 
Помогите ему: напишите функцию, которая печатает все его дела. 
Известно, что дел у Васи не больше 5000.

**Функция должна напечатать элементы списка по одному в строке.**

## C. Нелюбимое дело:
Вася размышляет, что бы такое из списка не делать. 
Но, кажется, все пункты очень важные! 
Вася решает загадать число и удалить дело, которое идёт под этим номером. 
Список дел представлен в виде односвязного списка. 

**Напишите функцию solution, которая принимает на вход голову списка**
**и номер удаляемого дела и возвращает голову обновлённого списка.**

## D. Заботливая мама
Мама Васи хочет знать, что сын планирует делать и когда. 
Помогите ей: напишите функцию solution, определяющую индекс первого вхождения 
передаваемого ей на вход значения в связном списке, если значение присутствует.

Функция на вход принимает голову односвязного списка и элемент, 
который нужно найти.

**Функция возвращает индекс первого вхождения искомого элемента**
в список(индексация начинается с нуля). 
Если элемент не найден, нужно вернуть -1. 

## E. Все наоборот:
Вася решил запутать маму —– делать дела в обратном порядке. 
Список его дел теперь хранится в двусвязном списке. 
Напишите функцию, которая вернёт список в обратном порядке.

Функция принимает на вход единственный аргумент — голову двусвязного списка.

**Функция должна вернуть голову развернутого списка.**

## F. Стек - Max
Нужно реализовать класс StackMax, который поддерживает операцию определения 
максимума среди всех элементов в стеке. Класс также должен поддерживать 
все операции, реализованные в классе Stack, из урока. 
При этом в классе StackMax может быть реализовано не более трёх методов.

Стек может содержать только данные типов, поддерживающих операцию сравнения. 
Иначе операция поиска максимума будет некорректной.

В первой строке записано одно число n - количество команд. 
n не превосходит 1000. В следующих n строках идут команды. 
Команды могут быть следующих видов:
push x - добавить число x в стек
pop - удалить число с вершины стека
get_max - напечатать максимальное число в стеке


Для каждой команды get_max напечатайте результат её выполнения. 
Если стек пустой, для команды get_max напечатайте None. 
Если происходит удаление из пустого стека - напечатайте error. 

## G. Стек - MaxEffective

Реализуйте класс StackMaxEffective, поддерживающий операцию определения 
максимума среди элементов в стеке. Сложность операции должна быть O(1). 
Для пустого стека операция должна возвращать None. 
При этом push и pop также должны выполняться за константное время.

В первой строке записано одно число - количество команд, 
оно не превосходит 1000. Далее идут команды по одной в строке. 
Команды могут быть следующих видов:
push x - добавить число x в стек
pop - удалить число с вершины стека
get_max - напечатать максимальное число в стеке

Для каждой команды get_max напечатайте результат её выполнения. 
Если стек пустой, для команды get_max напечатайте None. 
Если происходит удаление из пустого стека - напечатайте error.

## H. Скобочная последовательность
Вот какую задачу Тимофей предложил на собеседовании одному из кандидатов. 
Если вы с ней еще не сталкивались, то наверняка столкнётесь — она довольно 
популярная.

Дана скобочная последовательность. Нужно определить, правильная ли она.
Будем придерживаться такого определения:
- пустая строка — правильная скобочная последовательность;
- правильная скобочная последовательность, 
взятая в скобки одного типа, — правильная скобочная последовательность;
- правильная скобочная последовательность с приписанной слева или справа 
правильной скобочной последовательностью — тоже правильная.

На вход подается последовательность из скобок трёх видов: [], (), {}.

Напишите функцию is_correct_bracket_seq, которая принимает на вход 
скобочную последовательность и возвращает True, 
если последовательность правильная, иначе False.

На вход подается одна строка, содержащая скобочную последовательность.

## I. Ограниченная очередь
Далее Тимофею нужно написать класс MyQueueSized(), 
который принимает параметр max_size, означающий максимально допустимое 
количество элементов в очереди.

В первой строке записано одно число - количество команд, оно не превосходит 5000. 
Во второй строке задан максимально допустимый размер очереди, 
он не превосходит 5000. Далее идут команды по одной на строке. 
Команды могут быть следующих видов:
push x - добавить число x в очередь
pop - удалить число из очереди и вывести на печать
peek - напечатать первое число в очереди
size - вернуть размер очереди

При превышении допустимого размера очереди нужно вывести "error". 
При вызове операции pop для пустой очереди нужно вернуть None.

## J. Списочная очередь
Любимый вариант очереди Тимофея - очередь, 
написанная с использованием связного списка. 
Помогите ему с реализацией. Очередь должна поддерживать методы get, put, size.

В первой строке записано количество команд n - целое число, не превосходящее 1000.
В каждой из следующих n строк записана команда: get, put, или size.

При вызове метода get напечатайте возвращаемое значение. 
Если метод get вызывается у пустой очереди, нужно напечатать 'error'. 
При вызове метода size - вывести размер очереди.

# Финальные задачи
https://contest.yandex.ru/contest/23759/problems/

## A. Дек
Гоша решил реализовать структуру данных Дек, максимальный размер 
которого определяется заданным числом. 
Методы push_back, push_front, pop_front, pop_back работали корректно. 
Но, если в деке было много элементов, программа работала очень долго. 
Дело в том, что не все операции выполнялись за O(1). 
Помогите Гоше! Напишите эффективную реализацию.

В первой строке записано количество команд n - целое число, не превосходящее 5000. 
Во второй строке записано число m - максимальный размер стека. 
Он не превосходит 1000. 
В следующих n строках записана одна из команд:
push_back value
push_front value
pop_front
pop_back
value - целое число, по модулю не превосходящее 1000.

При вызове команд pop_front и pop_back нужно вывести возвращаемое значение. 
Если они вызываются для пустого стека - напечатайте 'error'. 
Если команда push_back или push_front вызывается для стека, 
размер которого равен максимально возможному, тоже нужно вывести 'error'.

## B. Калькулятор

Задание связано с обратной польской нотацией. Она используется для парсинга арифметических выражений. По сравнению с другим приемом, применяемым для данной задачи — использованием дерева операций, она является более компактной, так как в ней не используются скобки. Еще её иногда называют постфиксной нотацией.

В постфиксной нотации операнды расположены перед знаками операций.

Пример 1:  
3 4 +  
будет равно 7, и означает 3 + 4

Пример 2:  
10 2 4 * -  
будет равно 2, и означает 10 - 2 * 4

Разберем последний пример подробнее:

Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую этот знак обозначает, то есть перемножить эти два числа. В результате получим 8

После этого выражение приобретет вид:

10 8 -

Операцию минус нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.

Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.

Для вычисления значения выражения, записанного в обратной польской нотации, нужно считывать выражение слева направо и придерживаться следующих шагов:

1. Обработка входного символа: - Если на вход подан операнд, он помещается на вершину стека. - Если на вход подан знак операции, она выполняется над требуемым количеством значений из стека, взятых в порядке добавления. Результат выполненной операции помещается на вершину стека. 
2. Если входной набор символов обработан не полностью, перейти к шагу 1. 
3. После полной обработки входного набора символов результат вычисления выражения находится в вершине стека.


### Формат ввода
В единственной строке дано выражение, записанное в обратной польской нотации. Числа и арифметические операции отделены друг от друга пробелами.

На вход могут подаваться операции: +, -, *, / и числа, по модулю не превосходящие 10000.

Гарантируется, что значение промежуточных выражений в тестовых данных по модулю не больше 50000.

### Формат вывода 
Единственное число - значение выражения.
